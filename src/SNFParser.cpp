/** \file
 *  This C++ source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : SNF.g
 *     -                            On : 2012-12-17 12:31:42
 *     -                for the parser : SNFParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SNFParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace 	STRP  {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   SNFParserTokenNames[14+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "ID",
        (ANTLR_UINT8*) "WS",
        (ANTLR_UINT8*) "'('",
        (ANTLR_UINT8*) "')'",
        (ANTLR_UINT8*) "','",
        (ANTLR_UINT8*) "'.'",
        (ANTLR_UINT8*) "'['",
        (ANTLR_UINT8*) "']'",
        (ANTLR_UINT8*) "'always'",
        (ANTLR_UINT8*) "'and'",
        (ANTLR_UINT8*) "'next'",
        (ANTLR_UINT8*) "'not'",
        (ANTLR_UINT8*) "'or'",
        (ANTLR_UINT8*) "'sometime'"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "SNF.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* SNFParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new SNFParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SNFParser::SNFParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new SNFParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SNFParser::SNFParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void SNFParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( SNFParserTokenNames );


}

void
SNFParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
SNFParser::~SNFParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return SNFParserTokenNames;
}


    SNFFormula result;


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_13_in_formula78_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040) };
static  SNFParserImplTraits::BitsetListType FOLLOW_13_in_formula78( FOLLOW_13_in_formula78_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_6_in_formula79_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  SNFParserImplTraits::BitsetListType FOLLOW_6_in_formula79( FOLLOW_6_in_formula79_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_list_of_snfclauses_in_formula82_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SNFParserImplTraits::BitsetListType FOLLOW_list_of_snfclauses_in_formula82( FOLLOW_list_of_snfclauses_in_formula82_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_7_in_formula87_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200) };
static  SNFParserImplTraits::BitsetListType FOLLOW_7_in_formula87( FOLLOW_7_in_formula87_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_9_in_formula88_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_9_in_formula88( FOLLOW_9_in_formula88_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_10_in_list_of_snfclauses98_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  SNFParserImplTraits::BitsetListType FOLLOW_10_in_list_of_snfclauses98( FOLLOW_10_in_list_of_snfclauses98_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_11_in_list_of_snfclauses99_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_11_in_list_of_snfclauses99( FOLLOW_11_in_list_of_snfclauses99_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_10_in_list_of_snfclauses104_bits[]	= { ANTLR_UINT64_LIT(0x0000000000011000) };
static  SNFParserImplTraits::BitsetListType FOLLOW_10_in_list_of_snfclauses104( FOLLOW_10_in_list_of_snfclauses104_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_snfclause_in_list_of_snfclauses108_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000900) };
static  SNFParserImplTraits::BitsetListType FOLLOW_snfclause_in_list_of_snfclauses108( FOLLOW_snfclause_in_list_of_snfclauses108_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_8_in_list_of_snfclauses113_bits[]	= { ANTLR_UINT64_LIT(0x0000000000011000) };
static  SNFParserImplTraits::BitsetListType FOLLOW_8_in_list_of_snfclauses113( FOLLOW_8_in_list_of_snfclauses113_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_snfclause_in_list_of_snfclauses115_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000900) };
static  SNFParserImplTraits::BitsetListType FOLLOW_snfclause_in_list_of_snfclauses115( FOLLOW_snfclause_in_list_of_snfclauses115_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_11_in_list_of_snfclauses121_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_11_in_list_of_snfclauses121( FOLLOW_11_in_list_of_snfclauses121_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_12_in_snfclause132_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040) };
static  SNFParserImplTraits::BitsetListType FOLLOW_12_in_snfclause132( FOLLOW_12_in_snfclause132_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_6_in_snfclause133_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010000) };
static  SNFParserImplTraits::BitsetListType FOLLOW_6_in_snfclause133( FOLLOW_6_in_snfclause133_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_temporalclause_in_snfclause134_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SNFParserImplTraits::BitsetListType FOLLOW_temporalclause_in_snfclause134( FOLLOW_temporalclause_in_snfclause134_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_7_in_snfclause135_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_7_in_snfclause135( FOLLOW_7_in_snfclause135_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_clause_in_snfclause140_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_clause_in_snfclause140( FOLLOW_clause_in_snfclause140_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_clause_in_temporalclause152_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_clause_in_temporalclause152( FOLLOW_clause_in_temporalclause152_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_stepclause_in_temporalclause159_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_stepclause_in_temporalclause159( FOLLOW_stepclause_in_temporalclause159_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_uncond_stepclause_in_temporalclause166_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_uncond_stepclause_in_temporalclause166( FOLLOW_uncond_stepclause_in_temporalclause166_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_sometimeclause_in_temporalclause173_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_sometimeclause_in_temporalclause173( FOLLOW_sometimeclause_in_temporalclause173_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_uncond_sometimeclause_in_temporalclause180_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_uncond_sometimeclause_in_temporalclause180( FOLLOW_uncond_sometimeclause_in_temporalclause180_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_16_in_sometimeclause196_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040) };
static  SNFParserImplTraits::BitsetListType FOLLOW_16_in_sometimeclause196( FOLLOW_16_in_sometimeclause196_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_6_in_sometimeclause198_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  SNFParserImplTraits::BitsetListType FOLLOW_6_in_sometimeclause198( FOLLOW_6_in_sometimeclause198_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_10_in_sometimeclause200_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008010) };
static  SNFParserImplTraits::BitsetListType FOLLOW_10_in_sometimeclause200( FOLLOW_10_in_sometimeclause200_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_literal_in_sometimeclause207_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020100) };
static  SNFParserImplTraits::BitsetListType FOLLOW_literal_in_sometimeclause207( FOLLOW_literal_in_sometimeclause207_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_8_in_sometimeclause215_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008010) };
static  SNFParserImplTraits::BitsetListType FOLLOW_8_in_sometimeclause215( FOLLOW_8_in_sometimeclause215_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_literal_in_sometimeclause219_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020100) };
static  SNFParserImplTraits::BitsetListType FOLLOW_literal_in_sometimeclause219( FOLLOW_literal_in_sometimeclause219_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_8_in_sometimeclause227_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  SNFParserImplTraits::BitsetListType FOLLOW_8_in_sometimeclause227( FOLLOW_8_in_sometimeclause227_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_sometimeliteral_in_sometimeclause234_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  SNFParserImplTraits::BitsetListType FOLLOW_sometimeliteral_in_sometimeclause234( FOLLOW_sometimeliteral_in_sometimeclause234_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_11_in_sometimeclause239_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SNFParserImplTraits::BitsetListType FOLLOW_11_in_sometimeclause239( FOLLOW_11_in_sometimeclause239_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_7_in_sometimeclause240_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_7_in_sometimeclause240( FOLLOW_7_in_sometimeclause240_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_16_in_uncond_sometimeclause260_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040) };
static  SNFParserImplTraits::BitsetListType FOLLOW_16_in_uncond_sometimeclause260( FOLLOW_16_in_uncond_sometimeclause260_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_6_in_uncond_sometimeclause262_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  SNFParserImplTraits::BitsetListType FOLLOW_6_in_uncond_sometimeclause262( FOLLOW_6_in_uncond_sometimeclause262_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_10_in_uncond_sometimeclause264_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  SNFParserImplTraits::BitsetListType FOLLOW_10_in_uncond_sometimeclause264( FOLLOW_10_in_uncond_sometimeclause264_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_sometimeliteral_in_uncond_sometimeclause270_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000800) };
static  SNFParserImplTraits::BitsetListType FOLLOW_sometimeliteral_in_uncond_sometimeclause270( FOLLOW_sometimeliteral_in_uncond_sometimeclause270_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_11_in_uncond_sometimeclause275_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SNFParserImplTraits::BitsetListType FOLLOW_11_in_uncond_sometimeclause275( FOLLOW_11_in_uncond_sometimeclause275_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_7_in_uncond_sometimeclause276_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_7_in_uncond_sometimeclause276( FOLLOW_7_in_uncond_sometimeclause276_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_16_in_uncond_stepclause295_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040) };
static  SNFParserImplTraits::BitsetListType FOLLOW_16_in_uncond_stepclause295( FOLLOW_16_in_uncond_stepclause295_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_6_in_uncond_stepclause297_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  SNFParserImplTraits::BitsetListType FOLLOW_6_in_uncond_stepclause297( FOLLOW_6_in_uncond_stepclause297_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_10_in_uncond_stepclause299_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  SNFParserImplTraits::BitsetListType FOLLOW_10_in_uncond_stepclause299( FOLLOW_10_in_uncond_stepclause299_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_stepliteral_in_uncond_stepclause305_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000900) };
static  SNFParserImplTraits::BitsetListType FOLLOW_stepliteral_in_uncond_stepclause305( FOLLOW_stepliteral_in_uncond_stepclause305_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_8_in_uncond_stepclause312_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  SNFParserImplTraits::BitsetListType FOLLOW_8_in_uncond_stepclause312( FOLLOW_8_in_uncond_stepclause312_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_stepliteral_in_uncond_stepclause316_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000900) };
static  SNFParserImplTraits::BitsetListType FOLLOW_stepliteral_in_uncond_stepclause316( FOLLOW_stepliteral_in_uncond_stepclause316_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_11_in_uncond_stepclause323_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SNFParserImplTraits::BitsetListType FOLLOW_11_in_uncond_stepclause323( FOLLOW_11_in_uncond_stepclause323_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_7_in_uncond_stepclause324_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_7_in_uncond_stepclause324( FOLLOW_7_in_uncond_stepclause324_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_16_in_stepclause338_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040) };
static  SNFParserImplTraits::BitsetListType FOLLOW_16_in_stepclause338( FOLLOW_16_in_stepclause338_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_6_in_stepclause340_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  SNFParserImplTraits::BitsetListType FOLLOW_6_in_stepclause340( FOLLOW_6_in_stepclause340_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_10_in_stepclause342_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008010) };
static  SNFParserImplTraits::BitsetListType FOLLOW_10_in_stepclause342( FOLLOW_10_in_stepclause342_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_literal_in_stepclause349_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004100) };
static  SNFParserImplTraits::BitsetListType FOLLOW_literal_in_stepclause349( FOLLOW_literal_in_stepclause349_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_8_in_stepclause357_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008010) };
static  SNFParserImplTraits::BitsetListType FOLLOW_8_in_stepclause357( FOLLOW_8_in_stepclause357_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_literal_in_stepclause361_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004100) };
static  SNFParserImplTraits::BitsetListType FOLLOW_literal_in_stepclause361( FOLLOW_literal_in_stepclause361_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_8_in_stepclause370_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  SNFParserImplTraits::BitsetListType FOLLOW_8_in_stepclause370( FOLLOW_8_in_stepclause370_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_stepliteral_in_stepclause377_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000900) };
static  SNFParserImplTraits::BitsetListType FOLLOW_stepliteral_in_stepclause377( FOLLOW_stepliteral_in_stepclause377_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_8_in_stepclause384_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004000) };
static  SNFParserImplTraits::BitsetListType FOLLOW_8_in_stepclause384( FOLLOW_8_in_stepclause384_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_stepliteral_in_stepclause388_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000900) };
static  SNFParserImplTraits::BitsetListType FOLLOW_stepliteral_in_stepclause388( FOLLOW_stepliteral_in_stepclause388_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_11_in_stepclause395_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SNFParserImplTraits::BitsetListType FOLLOW_11_in_stepclause395( FOLLOW_11_in_stepclause395_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_7_in_stepclause396_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_7_in_stepclause396( FOLLOW_7_in_stepclause396_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_16_in_clause410_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040) };
static  SNFParserImplTraits::BitsetListType FOLLOW_16_in_clause410( FOLLOW_16_in_clause410_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_6_in_clause412_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000400) };
static  SNFParserImplTraits::BitsetListType FOLLOW_6_in_clause412( FOLLOW_6_in_clause412_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_10_in_clause414_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008010) };
static  SNFParserImplTraits::BitsetListType FOLLOW_10_in_clause414( FOLLOW_10_in_clause414_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_literal_in_clause420_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000900) };
static  SNFParserImplTraits::BitsetListType FOLLOW_literal_in_clause420( FOLLOW_literal_in_clause420_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_8_in_clause427_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008010) };
static  SNFParserImplTraits::BitsetListType FOLLOW_8_in_clause427( FOLLOW_8_in_clause427_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_literal_in_clause431_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000900) };
static  SNFParserImplTraits::BitsetListType FOLLOW_literal_in_clause431( FOLLOW_literal_in_clause431_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_11_in_clause438_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SNFParserImplTraits::BitsetListType FOLLOW_11_in_clause438( FOLLOW_11_in_clause438_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_7_in_clause439_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_7_in_clause439( FOLLOW_7_in_clause439_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_14_in_stepliteral454_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040) };
static  SNFParserImplTraits::BitsetListType FOLLOW_14_in_stepliteral454( FOLLOW_14_in_stepliteral454_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_6_in_stepliteral455_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008010) };
static  SNFParserImplTraits::BitsetListType FOLLOW_6_in_stepliteral455( FOLLOW_6_in_stepliteral455_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_literal_in_stepliteral456_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SNFParserImplTraits::BitsetListType FOLLOW_literal_in_stepliteral456( FOLLOW_literal_in_stepliteral456_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_7_in_stepliteral457_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_7_in_stepliteral457( FOLLOW_7_in_stepliteral457_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_17_in_sometimeliteral473_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040) };
static  SNFParserImplTraits::BitsetListType FOLLOW_17_in_sometimeliteral473( FOLLOW_17_in_sometimeliteral473_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_6_in_sometimeliteral474_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008010) };
static  SNFParserImplTraits::BitsetListType FOLLOW_6_in_sometimeliteral474( FOLLOW_6_in_sometimeliteral474_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_literal_in_sometimeliteral475_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SNFParserImplTraits::BitsetListType FOLLOW_literal_in_sometimeliteral475( FOLLOW_literal_in_sometimeliteral475_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_7_in_sometimeliteral476_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_7_in_sometimeliteral476( FOLLOW_7_in_sometimeliteral476_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_15_in_literal494_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000040) };
static  SNFParserImplTraits::BitsetListType FOLLOW_15_in_literal494( FOLLOW_15_in_literal494_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_6_in_literal495_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000010) };
static  SNFParserImplTraits::BitsetListType FOLLOW_6_in_literal495( FOLLOW_6_in_literal495_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_literal497_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SNFParserImplTraits::BitsetListType FOLLOW_ID_in_literal497( FOLLOW_ID_in_literal497_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_7_in_literal499_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_7_in_literal499( FOLLOW_7_in_literal499_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_15_in_literal505_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000010) };
static  SNFParserImplTraits::BitsetListType FOLLOW_15_in_literal505( FOLLOW_15_in_literal505_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_literal507_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_ID_in_literal507( FOLLOW_ID_in_literal507_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SNFParser  */
static	ANTLR_BITWORD FOLLOW_ID_in_literal514_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SNFParserImplTraits::BitsetListType FOLLOW_ID_in_literal514( FOLLOW_ID_in_literal514_bits, 1 );



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    61:1: temporalclause : ( clause | stepclause | uncond_stepclause | sometimeclause | uncond_sometimeclause );
 */
static const ANTLR_INT32 dfa4_eot[22] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };
static const ANTLR_INT32 dfa4_eof[22] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };
static const ANTLR_INT32 dfa4_min[22] =
    {
	16, 6, 10, 4, 4, 8, -1, -1, 4, 8, 4, -1, -1, -1, 7, 4, 8, 8, 4, 8, 7, 8
    };
static const ANTLR_INT32 dfa4_max[22] =
    {
	16, 6, 10, 17, 6, 17, -1, -1, 4, 17, 17, -1, -1, -1, 7, 6, 17, 17, 4, 17, 
	7, 17
    };
static const ANTLR_INT32 dfa4_accept[22] =
    {
	-1, -1, -1, -1, -1, -1, 3, 5, -1, -1, -1, 1, 2, 4, -1, -1, -1, -1, -1, 
	-1, -1, -1
    };
static const ANTLR_INT32 dfa4_special[22] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
static const ANTLR_INT32* dfa4_T_empty	 =   NULL;

static const ANTLR_INT32 dfa4_T0[] =
    {
	10, -1, -1, 11, -1, -1, 12, -1, -1, 13
    };

static const ANTLR_INT32 dfa4_T1[] =
    {
	16, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 15, -1, 13
    };

static const ANTLR_INT32 dfa4_T2[] =
    {
	2
    };

static const ANTLR_INT32 dfa4_T3[] =
    {
	21
    };

static const ANTLR_INT32 dfa4_T4[] =
    {
	17
    };

static const ANTLR_INT32 dfa4_T5[] =
    {
	3
    };

static const ANTLR_INT32 dfa4_T6[] =
    {
	20
    };

static const ANTLR_INT32 dfa4_T7[] =
    {
	14
    };

static const ANTLR_INT32 dfa4_T8[] =
    {
	5, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 4, -1, 7
    };

static const ANTLR_INT32 dfa4_T9[] =
    {
	1
    };

static const ANTLR_INT32 dfa4_T10[] =
    {
	19, -1, 18
    };

static const ANTLR_INT32 dfa4_T11[] =
    {
	9, -1, 8
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR_INT32 * const dfa4_transitions[] =
{
    dfa4_T9, dfa4_T2, dfa4_T5, dfa4_T8, dfa4_T11, dfa4_T0, NULL, NULL, dfa4_T7, 
    dfa4_T0, dfa4_T1, NULL, NULL, NULL, dfa4_T4, dfa4_T10, dfa4_T0, dfa4_T0, 
    dfa4_T6, dfa4_T0, dfa4_T3, dfa4_T0
};


/* Declare tracking structure for Cyclic DFA 4
 */
class SNFParserCyclicDFA4 : public CyclicDFA< SNFParserImplTraits, SNFParser >, public SNFParserTokens
{
public:
	typedef CyclicDFA< SNFParserImplTraits, SNFParser >  BaseType;
	typedef BaseType::ContextType CtxType;

private:
	

public:
	SNFParserCyclicDFA4( ANTLR_INT32	decisionNumber
					, const ANTLR_UCHAR*	description
					, const ANTLR_INT32* const	eot
					, const ANTLR_INT32* const	eof
					, const ANTLR_INT32* const	min
					, const ANTLR_INT32* const	max
					, const ANTLR_INT32* const	accept
					, const ANTLR_INT32* const	special
					, const ANTLR_INT32* const *const	transition)
					:BaseType( decisionNumber, description, eot, eof, min, max, accept,
								special, transition )
	{
		
	}

};

static SNFParserCyclicDFA4  cdfa4(
	    4,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const ANTLR_UCHAR*)"61:1: temporalclause : ( clause | stepclause | uncond_stepclause | sometimeclause | uncond_sometimeclause );",
	    dfa4_eot,	    /* EOT table			    */
	    dfa4_eof,	    /* EOF table			    */
	    dfa4_min,	    /* Minimum tokens for each state    */
	    dfa4_max,	    /* Maximum tokens for each state    */
	    dfa4_accept,	/* Accept table			    */
	    dfa4_special,	/* Special transition states	    */
	    dfa4_transitions	/* Table of transition tables	    */

	);


/* End of Cyclic DFA 4
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start formula
 * SNF.g:40:1: formula returns [SNFFormula f] : 'and' '(' list_of_snfclauses ')' '.' ;
 */
SNFFormula
SNFParser::formula()
{
        SNFParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SNFFormula f;


    /* Initialize rule variables
     */


 
    {
        // SNF.g:41:2: ( 'and' '(' list_of_snfclauses ')' '.' )
        // SNF.g:42:2: 'and' '(' list_of_snfclauses ')' '.'
        {
             this->matchToken(13, &FOLLOW_13_in_formula78);
            if  (this->hasException())
            {
                goto ruleformulaEx;
            }


             this->matchToken(6, &FOLLOW_6_in_formula79);
            if  (this->hasException())
            {
                goto ruleformulaEx;
            }


            this->followPush(FOLLOW_list_of_snfclauses_in_formula82);
            list_of_snfclauses();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleformulaEx;
            }


            {
                f = result;
            }


             this->matchToken(7, &FOLLOW_7_in_formula87);
            if  (this->hasException())
            {
                goto ruleformulaEx;
            }


             this->matchToken(9, &FOLLOW_9_in_formula88);
            if  (this->hasException())
            {
                goto ruleformulaEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleformulaEx; /* Prevent compiler warnings */
    ruleformulaEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return f;
}
/* $ANTLR end formula */

/**
 * $ANTLR start list_of_snfclauses
 * SNF.g:47:1: list_of_snfclauses : ( '[' ']' | '[' snfclause ( ',' snfclause )* ']' );
 */
void
SNFParser::list_of_snfclauses()
{
        SNFParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  SNF.g:48:4: ( '[' ']' | '[' snfclause ( ',' snfclause )* ']' )

            ANTLR_UINT32 alt2;

            alt2=2;

            switch ( this->LA(1) )
            {
            case 10:
            	{
            		switch ( this->LA(2) )
            		{
            		case 11:
            			{
            				alt2=1;
            			}
            		    break;
            		case 12:
            		case 16:
            			{
            				alt2=2;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SNFParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 2 );
            		    ex->set_state( 1 );


            		    goto rulelist_of_snfclausesEx;

            		}

            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SNFParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 2 );
                ex->set_state( 0 );


                goto rulelist_of_snfclausesEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // SNF.g:48:4: '[' ']'
        	    {
        	         this->matchToken(10, &FOLLOW_10_in_list_of_snfclauses98);
        	        if  (this->hasException())
        	        {
        	            goto rulelist_of_snfclausesEx;
        	        }


        	         this->matchToken(11, &FOLLOW_11_in_list_of_snfclauses99);
        	        if  (this->hasException())
        	        {
        	            goto rulelist_of_snfclausesEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // SNF.g:49:2: '[' snfclause ( ',' snfclause )* ']'
        	    {
        	         this->matchToken(10, &FOLLOW_10_in_list_of_snfclauses104);
        	        if  (this->hasException())
        	        {
        	            goto rulelist_of_snfclausesEx;
        	        }


        	        this->followPush(FOLLOW_snfclause_in_list_of_snfclauses108);
        	        snfclause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelist_of_snfclausesEx;
        	        }


        	        // SNF.g:51:2: ( ',' snfclause )*

        	        for (;;)
        	        {
        	            int alt1=2;
        	            switch ( this->LA(1) )
        	            {
        	            case 8:
        	            	{
        	            		alt1=1;
        	            	}
        	                break;

        	            }

        	            switch (alt1)
        	            {
        	        	case 1:
        	        	    // SNF.g:51:3: ',' snfclause
        	        	    {
        	        	         this->matchToken(8, &FOLLOW_8_in_list_of_snfclauses113);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulelist_of_snfclausesEx;
        	        	        }


        	        	        this->followPush(FOLLOW_snfclause_in_list_of_snfclauses115);
        	        	        snfclause();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulelist_of_snfclausesEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop1;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop1: ; /* Jump out to here if this rule does not match */


        	         this->matchToken(11, &FOLLOW_11_in_list_of_snfclauses121);
        	        if  (this->hasException())
        	        {
        	            goto rulelist_of_snfclausesEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulelist_of_snfclausesEx; /* Prevent compiler warnings */
    rulelist_of_snfclausesEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end list_of_snfclauses */

/**
 * $ANTLR start snfclause
 * SNF.g:55:1: snfclause : ( 'always' '(' temporalclause ')' | clause );
 */
void
SNFParser::snfclause()
{
        SNFParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    T_Clause clause1;
    typedef	T_Clause RETURN_TYPE_clause1;

    /* Initialize rule variables
     */


 
    {
        {
            //  SNF.g:56:2: ( 'always' '(' temporalclause ')' | clause )

            ANTLR_UINT32 alt3;

            alt3=2;

            switch ( this->LA(1) )
            {
            case 12:
            	{
            		alt3=1;
            	}
                break;
            case 16:
            	{
            		alt3=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SNFParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 3 );
                ex->set_state( 0 );


                goto rulesnfclauseEx;

            }

            switch (alt3)
            {
        	case 1:
        	    // SNF.g:57:2: 'always' '(' temporalclause ')'
        	    {
        	         this->matchToken(12, &FOLLOW_12_in_snfclause132);
        	        if  (this->hasException())
        	        {
        	            goto rulesnfclauseEx;
        	        }


        	         this->matchToken(6, &FOLLOW_6_in_snfclause133);
        	        if  (this->hasException())
        	        {
        	            goto rulesnfclauseEx;
        	        }


        	        this->followPush(FOLLOW_temporalclause_in_snfclause134);
        	        temporalclause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesnfclauseEx;
        	        }


        	         this->matchToken(7, &FOLLOW_7_in_snfclause135);
        	        if  (this->hasException())
        	        {
        	            goto rulesnfclauseEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // SNF.g:58:2: clause
        	    {
        	        this->followPush(FOLLOW_clause_in_snfclause140);
        	        clause1=clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesnfclauseEx;
        	        }


        	        {
        	            result.initial.push_back(clause1
        	            );
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesnfclauseEx; /* Prevent compiler warnings */
    rulesnfclauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end snfclause */

/**
 * $ANTLR start temporalclause
 * SNF.g:61:1: temporalclause : ( clause | stepclause | uncond_stepclause | sometimeclause | uncond_sometimeclause );
 */
void
SNFParser::temporalclause()
{
        SNFParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    T_Clause clause2;
    typedef	T_Clause RETURN_TYPE_clause2;

    StepClause stepclause3;
    typedef	StepClause RETURN_TYPE_stepclause3;

    StepClause uncond_stepclause4;
    typedef	StepClause RETURN_TYPE_uncond_stepclause4;

    SometimeClause sometimeclause5;
    typedef	SometimeClause RETURN_TYPE_sometimeclause5;

    SometimeClause uncond_sometimeclause6;
    typedef	SometimeClause RETURN_TYPE_uncond_sometimeclause6;

    /* Initialize rule variables
     */


 
    {
        {
            //  SNF.g:62:2: ( clause | stepclause | uncond_stepclause | sometimeclause | uncond_sometimeclause )

            ANTLR_UINT32 alt4;

            alt4=5;

            alt4 = cdfa4.predict(this, this->get_rec(), this->get_istream(), cdfa4 );
            if  (this->hasException())
            {
                goto ruletemporalclauseEx;
            }

            switch (alt4)
            {
        	case 1:
        	    // SNF.g:63:2: clause
        	    {
        	        this->followPush(FOLLOW_clause_in_temporalclause152);
        	        clause2=clause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletemporalclauseEx;
        	        }


        	        {
        	            result.universal.push_back(clause2
        	            );
        	        }


        	    }
        	    break;
        	case 2:
        	    // SNF.g:64:4: stepclause
        	    {
        	        this->followPush(FOLLOW_stepclause_in_temporalclause159);
        	        stepclause3=stepclause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletemporalclauseEx;
        	        }


        	        {
        	            result.step.push_back(stepclause3
        	            );
        	        }


        	    }
        	    break;
        	case 3:
        	    // SNF.g:65:4: uncond_stepclause
        	    {
        	        this->followPush(FOLLOW_uncond_stepclause_in_temporalclause166);
        	        uncond_stepclause4=uncond_stepclause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletemporalclauseEx;
        	        }


        	        {
        	            result.step.push_back(uncond_stepclause4
        	            );
        	        }


        	    }
        	    break;
        	case 4:
        	    // SNF.g:66:4: sometimeclause
        	    {
        	        this->followPush(FOLLOW_sometimeclause_in_temporalclause173);
        	        sometimeclause5=sometimeclause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletemporalclauseEx;
        	        }


        	        {
        	            result.sometime.push_back(sometimeclause5
        	            );
        	        }


        	    }
        	    break;
        	case 5:
        	    // SNF.g:67:4: uncond_sometimeclause
        	    {
        	        this->followPush(FOLLOW_uncond_sometimeclause_in_temporalclause180);
        	        uncond_sometimeclause6=uncond_sometimeclause();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruletemporalclauseEx;
        	        }


        	        {
        	            result.sometime.push_back(uncond_sometimeclause6
        	            );
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruletemporalclauseEx; /* Prevent compiler warnings */
    ruletemporalclauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end temporalclause */

/**
 * $ANTLR start sometimeclause
 * SNF.g:70:1: sometimeclause returns [SometimeClause socl] : 'or' '(' '[' (l1= literal ) ( ',' l2= literal )* ( ',' )? so1= sometimeliteral ']' ')' ;
 */
SometimeClause
SNFParser::sometimeclause()
{
        SNFParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SometimeClause socl;


    int l1;
    typedef	int RETURN_TYPE_l1;

    int l2;
    typedef	int RETURN_TYPE_l2;

    int so1;
    typedef	int RETURN_TYPE_so1;

    /* Initialize rule variables
     */


 
    {
        // SNF.g:71:2: ( 'or' '(' '[' (l1= literal ) ( ',' l2= literal )* ( ',' )? so1= sometimeliteral ']' ')' )
        // SNF.g:72:2: 'or' '(' '[' (l1= literal ) ( ',' l2= literal )* ( ',' )? so1= sometimeliteral ']' ')'
        {
             this->matchToken(16, &FOLLOW_16_in_sometimeclause196);
            if  (this->hasException())
            {
                goto rulesometimeclauseEx;
            }


             this->matchToken(6, &FOLLOW_6_in_sometimeclause198);
            if  (this->hasException())
            {
                goto rulesometimeclauseEx;
            }


             this->matchToken(10, &FOLLOW_10_in_sometimeclause200);
            if  (this->hasException())
            {
                goto rulesometimeclauseEx;
            }


            // SNF.g:73:3: (l1= literal )
            // SNF.g:73:4: l1= literal
            {
                this->followPush(FOLLOW_literal_in_sometimeclause207);
                l1=literal();

                this->followPop();
                if  (this->hasException())
                {
                    goto rulesometimeclauseEx;
                }


                {
                    socl.first.insert(l1
                    );
                }


            }


            // SNF.g:74:3: ( ',' l2= literal )*

            for (;;)
            {
                int alt5=2;
                switch ( this->LA(1) )
                {
                case 8:
                	{
                		switch ( this->LA(2) )
                		{
                		case ID:
                		case 15:
                			{
                				alt5=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt5)
                {
            	case 1:
            	    // SNF.g:74:4: ',' l2= literal
            	    {
            	         this->matchToken(8, &FOLLOW_8_in_sometimeclause215);
            	        if  (this->hasException())
            	        {
            	            goto rulesometimeclauseEx;
            	        }


            	        this->followPush(FOLLOW_literal_in_sometimeclause219);
            	        l2=literal();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesometimeclauseEx;
            	        }


            	        {
            	            socl.first.insert(l2
            	            );
            	        }


            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */


            // SNF.g:75:3: ( ',' )?
            {
                int alt6=2;
                switch ( this->LA(1) )
                {
                    case 8:
                    	{
                    		alt6=1;
                    	}
                        break;
                }

                switch (alt6)
                {
            	case 1:
            	    // SNF.g:75:3: ','
            	    {
            	         this->matchToken(8, &FOLLOW_8_in_sometimeclause227);
            	        if  (this->hasException())
            	        {
            	            goto rulesometimeclauseEx;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_sometimeliteral_in_sometimeclause234);
            so1=sometimeliteral();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesometimeclauseEx;
            }


            {
                socl.second = so1
                ;
            }


             this->matchToken(11, &FOLLOW_11_in_sometimeclause239);
            if  (this->hasException())
            {
                goto rulesometimeclauseEx;
            }


             this->matchToken(7, &FOLLOW_7_in_sometimeclause240);
            if  (this->hasException())
            {
                goto rulesometimeclauseEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesometimeclauseEx; /* Prevent compiler warnings */
    rulesometimeclauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return socl;
}
/* $ANTLR end sometimeclause */

/**
 * $ANTLR start uncond_sometimeclause
 * SNF.g:81:1: uncond_sometimeclause returns [SometimeClause socl] : 'or' '(' '[' so1= sometimeliteral ']' ')' ;
 */
SometimeClause
SNFParser::uncond_sometimeclause()
{
        SNFParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SometimeClause socl;


    int so1;
    typedef	int RETURN_TYPE_so1;

    /* Initialize rule variables
     */

    socl.first.insert(-1);

 
    {
        // SNF.g:83:2: ( 'or' '(' '[' so1= sometimeliteral ']' ')' )
        // SNF.g:84:2: 'or' '(' '[' so1= sometimeliteral ']' ')'
        {
             this->matchToken(16, &FOLLOW_16_in_uncond_sometimeclause260);
            if  (this->hasException())
            {
                goto ruleuncond_sometimeclauseEx;
            }


             this->matchToken(6, &FOLLOW_6_in_uncond_sometimeclause262);
            if  (this->hasException())
            {
                goto ruleuncond_sometimeclauseEx;
            }


             this->matchToken(10, &FOLLOW_10_in_uncond_sometimeclause264);
            if  (this->hasException())
            {
                goto ruleuncond_sometimeclauseEx;
            }


            this->followPush(FOLLOW_sometimeliteral_in_uncond_sometimeclause270);
            so1=sometimeliteral();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleuncond_sometimeclauseEx;
            }


            {
                socl.second = so1
                ;
            }


             this->matchToken(11, &FOLLOW_11_in_uncond_sometimeclause275);
            if  (this->hasException())
            {
                goto ruleuncond_sometimeclauseEx;
            }


             this->matchToken(7, &FOLLOW_7_in_uncond_sometimeclause276);
            if  (this->hasException())
            {
                goto ruleuncond_sometimeclauseEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuncond_sometimeclauseEx; /* Prevent compiler warnings */
    ruleuncond_sometimeclauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return socl;
}
/* $ANTLR end uncond_sometimeclause */

/**
 * $ANTLR start uncond_stepclause
 * SNF.g:89:1: uncond_stepclause returns [StepClause stcl] : 'or' '(' '[' sl1= stepliteral ( ',' sl2= stepliteral )* ']' ')' ;
 */
StepClause
SNFParser::uncond_stepclause()
{
        SNFParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    StepClause stcl;


    int sl1;
    typedef	int RETURN_TYPE_sl1;

    int sl2;
    typedef	int RETURN_TYPE_sl2;

    /* Initialize rule variables
     */

    stcl.first.insert(-1);

 
    {
        // SNF.g:91:2: ( 'or' '(' '[' sl1= stepliteral ( ',' sl2= stepliteral )* ']' ')' )
        // SNF.g:92:2: 'or' '(' '[' sl1= stepliteral ( ',' sl2= stepliteral )* ']' ')'
        {
             this->matchToken(16, &FOLLOW_16_in_uncond_stepclause295);
            if  (this->hasException())
            {
                goto ruleuncond_stepclauseEx;
            }


             this->matchToken(6, &FOLLOW_6_in_uncond_stepclause297);
            if  (this->hasException())
            {
                goto ruleuncond_stepclauseEx;
            }


             this->matchToken(10, &FOLLOW_10_in_uncond_stepclause299);
            if  (this->hasException())
            {
                goto ruleuncond_stepclauseEx;
            }


            this->followPush(FOLLOW_stepliteral_in_uncond_stepclause305);
            sl1=stepliteral();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleuncond_stepclauseEx;
            }


            {
                stcl.second.insert(sl1
                );
            }


            // SNF.g:94:3: ( ',' sl2= stepliteral )*

            for (;;)
            {
                int alt7=2;
                switch ( this->LA(1) )
                {
                case 8:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7)
                {
            	case 1:
            	    // SNF.g:94:4: ',' sl2= stepliteral
            	    {
            	         this->matchToken(8, &FOLLOW_8_in_uncond_stepclause312);
            	        if  (this->hasException())
            	        {
            	            goto ruleuncond_stepclauseEx;
            	        }


            	        this->followPush(FOLLOW_stepliteral_in_uncond_stepclause316);
            	        sl2=stepliteral();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleuncond_stepclauseEx;
            	        }


            	        {
            	            stcl.second.insert(sl2
            	            );
            	        }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


             this->matchToken(11, &FOLLOW_11_in_uncond_stepclause323);
            if  (this->hasException())
            {
                goto ruleuncond_stepclauseEx;
            }


             this->matchToken(7, &FOLLOW_7_in_uncond_stepclause324);
            if  (this->hasException())
            {
                goto ruleuncond_stepclauseEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleuncond_stepclauseEx; /* Prevent compiler warnings */
    ruleuncond_stepclauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return stcl;
}
/* $ANTLR end uncond_stepclause */

/**
 * $ANTLR start stepclause
 * SNF.g:98:1: stepclause returns [StepClause stcl] : 'or' '(' '[' (l1= literal ) ( ',' l2= literal )* ( ',' )? sl1= stepliteral ( ',' sl2= stepliteral )* ']' ')' ;
 */
StepClause
SNFParser::stepclause()
{
        SNFParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    StepClause stcl;


    int l1;
    typedef	int RETURN_TYPE_l1;

    int l2;
    typedef	int RETURN_TYPE_l2;

    int sl1;
    typedef	int RETURN_TYPE_sl1;

    int sl2;
    typedef	int RETURN_TYPE_sl2;

    /* Initialize rule variables
     */


 
    {
        // SNF.g:99:2: ( 'or' '(' '[' (l1= literal ) ( ',' l2= literal )* ( ',' )? sl1= stepliteral ( ',' sl2= stepliteral )* ']' ')' )
        // SNF.g:100:2: 'or' '(' '[' (l1= literal ) ( ',' l2= literal )* ( ',' )? sl1= stepliteral ( ',' sl2= stepliteral )* ']' ')'
        {
             this->matchToken(16, &FOLLOW_16_in_stepclause338);
            if  (this->hasException())
            {
                goto rulestepclauseEx;
            }


             this->matchToken(6, &FOLLOW_6_in_stepclause340);
            if  (this->hasException())
            {
                goto rulestepclauseEx;
            }


             this->matchToken(10, &FOLLOW_10_in_stepclause342);
            if  (this->hasException())
            {
                goto rulestepclauseEx;
            }


            // SNF.g:101:3: (l1= literal )
            // SNF.g:101:4: l1= literal
            {
                this->followPush(FOLLOW_literal_in_stepclause349);
                l1=literal();

                this->followPop();
                if  (this->hasException())
                {
                    goto rulestepclauseEx;
                }


                {
                    stcl.first.insert(l1
                    );
                }


            }


            // SNF.g:102:3: ( ',' l2= literal )*

            for (;;)
            {
                int alt8=2;
                switch ( this->LA(1) )
                {
                case 8:
                	{
                		switch ( this->LA(2) )
                		{
                		case ID:
                		case 15:
                			{
                				alt8=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt8)
                {
            	case 1:
            	    // SNF.g:102:4: ',' l2= literal
            	    {
            	         this->matchToken(8, &FOLLOW_8_in_stepclause357);
            	        if  (this->hasException())
            	        {
            	            goto rulestepclauseEx;
            	        }


            	        this->followPush(FOLLOW_literal_in_stepclause361);
            	        l2=literal();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulestepclauseEx;
            	        }


            	        {
            	            stcl.first.insert(l2
            	            );
            	        }


            	    }
            	    break;

            	default:
            	    goto loop8;	/* break out of the loop */
            	    break;
                }
            }
            loop8: ; /* Jump out to here if this rule does not match */


            // SNF.g:103:3: ( ',' )?
            {
                int alt9=2;
                switch ( this->LA(1) )
                {
                    case 8:
                    	{
                    		alt9=1;
                    	}
                        break;
                }

                switch (alt9)
                {
            	case 1:
            	    // SNF.g:103:3: ','
            	    {
            	         this->matchToken(8, &FOLLOW_8_in_stepclause370);
            	        if  (this->hasException())
            	        {
            	            goto rulestepclauseEx;
            	        }


            	    }
            	    break;

                }
            }

            this->followPush(FOLLOW_stepliteral_in_stepclause377);
            sl1=stepliteral();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestepclauseEx;
            }


            {
                stcl.second.insert(sl1
                );
            }


            // SNF.g:105:3: ( ',' sl2= stepliteral )*

            for (;;)
            {
                int alt10=2;
                switch ( this->LA(1) )
                {
                case 8:
                	{
                		alt10=1;
                	}
                    break;

                }

                switch (alt10)
                {
            	case 1:
            	    // SNF.g:105:4: ',' sl2= stepliteral
            	    {
            	         this->matchToken(8, &FOLLOW_8_in_stepclause384);
            	        if  (this->hasException())
            	        {
            	            goto rulestepclauseEx;
            	        }


            	        this->followPush(FOLLOW_stepliteral_in_stepclause388);
            	        sl2=stepliteral();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulestepclauseEx;
            	        }


            	        {
            	            stcl.second.insert(sl2
            	            );
            	        }


            	    }
            	    break;

            	default:
            	    goto loop10;	/* break out of the loop */
            	    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */


             this->matchToken(11, &FOLLOW_11_in_stepclause395);
            if  (this->hasException())
            {
                goto rulestepclauseEx;
            }


             this->matchToken(7, &FOLLOW_7_in_stepclause396);
            if  (this->hasException())
            {
                goto rulestepclauseEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestepclauseEx; /* Prevent compiler warnings */
    rulestepclauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return stcl;
}
/* $ANTLR end stepclause */

/**
 * $ANTLR start clause
 * SNF.g:109:1: clause returns [T_Clause cl] : 'or' '(' '[' l1= literal ( ',' l2= literal )* ']' ')' ;
 */
T_Clause
SNFParser::clause()
{
        SNFParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    T_Clause cl;


    int l1;
    typedef	int RETURN_TYPE_l1;

    int l2;
    typedef	int RETURN_TYPE_l2;

    /* Initialize rule variables
     */


 
    {
        // SNF.g:110:2: ( 'or' '(' '[' l1= literal ( ',' l2= literal )* ']' ')' )
        // SNF.g:111:2: 'or' '(' '[' l1= literal ( ',' l2= literal )* ']' ')'
        {
             this->matchToken(16, &FOLLOW_16_in_clause410);
            if  (this->hasException())
            {
                goto ruleclauseEx;
            }


             this->matchToken(6, &FOLLOW_6_in_clause412);
            if  (this->hasException())
            {
                goto ruleclauseEx;
            }


             this->matchToken(10, &FOLLOW_10_in_clause414);
            if  (this->hasException())
            {
                goto ruleclauseEx;
            }


            this->followPush(FOLLOW_literal_in_clause420);
            l1=literal();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleclauseEx;
            }


            {
                cl.insert(l1
                );
            }


            // SNF.g:113:3: ( ',' l2= literal )*

            for (;;)
            {
                int alt11=2;
                switch ( this->LA(1) )
                {
                case 8:
                	{
                		alt11=1;
                	}
                    break;

                }

                switch (alt11)
                {
            	case 1:
            	    // SNF.g:113:4: ',' l2= literal
            	    {
            	         this->matchToken(8, &FOLLOW_8_in_clause427);
            	        if  (this->hasException())
            	        {
            	            goto ruleclauseEx;
            	        }


            	        this->followPush(FOLLOW_literal_in_clause431);
            	        l2=literal();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleclauseEx;
            	        }


            	        {
            	            cl.insert(l2
            	            );
            	        }


            	    }
            	    break;

            	default:
            	    goto loop11;	/* break out of the loop */
            	    break;
                }
            }
            loop11: ; /* Jump out to here if this rule does not match */


             this->matchToken(11, &FOLLOW_11_in_clause438);
            if  (this->hasException())
            {
                goto ruleclauseEx;
            }


             this->matchToken(7, &FOLLOW_7_in_clause439);
            if  (this->hasException())
            {
                goto ruleclauseEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleclauseEx; /* Prevent compiler warnings */
    ruleclauseEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return cl;
}
/* $ANTLR end clause */

/**
 * $ANTLR start stepliteral
 * SNF.g:118:1: stepliteral returns [int var] : 'next' '(' literal ')' ;
 */
int
SNFParser::stepliteral()
{
        SNFParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    int var;


    int literal7;
    typedef	int RETURN_TYPE_literal7;

    /* Initialize rule variables
     */


 
    {
        // SNF.g:119:2: ( 'next' '(' literal ')' )
        // SNF.g:120:2: 'next' '(' literal ')'
        {
             this->matchToken(14, &FOLLOW_14_in_stepliteral454);
            if  (this->hasException())
            {
                goto rulestepliteralEx;
            }


             this->matchToken(6, &FOLLOW_6_in_stepliteral455);
            if  (this->hasException())
            {
                goto rulestepliteralEx;
            }


            this->followPush(FOLLOW_literal_in_stepliteral456);
            literal7=literal();

            this->followPop();
            if  (this->hasException())
            {
                goto rulestepliteralEx;
            }


             this->matchToken(7, &FOLLOW_7_in_stepliteral457);
            if  (this->hasException())
            {
                goto rulestepliteralEx;
            }


            {
                var = literal7
                ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulestepliteralEx; /* Prevent compiler warnings */
    rulestepliteralEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return var;
}
/* $ANTLR end stepliteral */

/**
 * $ANTLR start sometimeliteral
 * SNF.g:123:1: sometimeliteral returns [int var] : 'sometime' '(' literal ')' ;
 */
int
SNFParser::sometimeliteral()
{
        SNFParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    int var;


    int literal8;
    typedef	int RETURN_TYPE_literal8;

    /* Initialize rule variables
     */


 
    {
        // SNF.g:124:2: ( 'sometime' '(' literal ')' )
        // SNF.g:125:2: 'sometime' '(' literal ')'
        {
             this->matchToken(17, &FOLLOW_17_in_sometimeliteral473);
            if  (this->hasException())
            {
                goto rulesometimeliteralEx;
            }


             this->matchToken(6, &FOLLOW_6_in_sometimeliteral474);
            if  (this->hasException())
            {
                goto rulesometimeliteralEx;
            }


            this->followPush(FOLLOW_literal_in_sometimeliteral475);
            literal8=literal();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesometimeliteralEx;
            }


             this->matchToken(7, &FOLLOW_7_in_sometimeliteral476);
            if  (this->hasException())
            {
                goto rulesometimeliteralEx;
            }


            {
                var = literal8
                ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesometimeliteralEx; /* Prevent compiler warnings */
    rulesometimeliteralEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return var;
}
/* $ANTLR end sometimeliteral */

/**
 * $ANTLR start literal
 * SNF.g:129:1: literal returns [int var] : ( 'not' '(' ( ID ) ')' | 'not' ID | ID );
 */
int
SNFParser::literal()
{
        SNFParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    int var;


    const CommonTokenType*    ID9;
    const CommonTokenType*    ID10;
    const CommonTokenType*    ID11;

    /* Initialize rule variables
     */

    ID9       = NULL;
    ID10       = NULL;
    ID11       = NULL;


 
    {
        {
            //  SNF.g:130:2: ( 'not' '(' ( ID ) ')' | 'not' ID | ID )

            ANTLR_UINT32 alt12;

            alt12=3;

            switch ( this->LA(1) )
            {
            case 15:
            	{
            		switch ( this->LA(2) )
            		{
            		case 6:
            			{
            				alt12=1;
            			}
            		    break;
            		case ID:
            			{
            				alt12=2;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SNFParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 12 );
            		    ex->set_state( 1 );


            		    goto ruleliteralEx;

            		}

            	}
                break;
            case ID:
            	{
            		alt12=3;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SNFParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 12 );
                ex->set_state( 0 );


                goto ruleliteralEx;

            }

            switch (alt12)
            {
        	case 1:
        	    // SNF.g:131:2: 'not' '(' ( ID ) ')'
        	    {
        	         this->matchToken(15, &FOLLOW_15_in_literal494);
        	        if  (this->hasException())
        	        {
        	            goto ruleliteralEx;
        	        }


        	         this->matchToken(6, &FOLLOW_6_in_literal495);
        	        if  (this->hasException())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        // SNF.g:131:10: ( ID )
        	        // SNF.g:131:11: ID
        	        {
        	            ID9 =  this->matchToken(ID, &FOLLOW_ID_in_literal497);
        	            if  (this->hasException())
        	            {
        	                goto ruleliteralEx;
        	            }


        	        }


        	         this->matchToken(7, &FOLLOW_7_in_literal499);
        	        if  (this->hasException())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {
        	             var = (result.table.getVar((ID9->getText())) * -1); 
        	        }


        	    }
        	    break;
        	case 2:
        	    // SNF.g:132:4: 'not' ID
        	    {
        	         this->matchToken(15, &FOLLOW_15_in_literal505);
        	        if  (this->hasException())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        ID10 =  this->matchToken(ID, &FOLLOW_ID_in_literal507);
        	        if  (this->hasException())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {
        	             var = (result.table.getVar((ID10->getText())) * -1); 
        	        }


        	    }
        	    break;
        	case 3:
        	    // SNF.g:133:4: ID
        	    {
        	        ID11 =  this->matchToken(ID, &FOLLOW_ID_in_literal514);
        	        if  (this->hasException())
        	        {
        	            goto ruleliteralEx;
        	        }


        	        {
        	             var = result.table.getVar((ID11->getText())); 
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleliteralEx; /* Prevent compiler warnings */
    ruleliteralEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return var;
}
/* $ANTLR end literal */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
