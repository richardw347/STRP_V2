#include "SNFLexer.hpp"
#include "SNFParser.hpp"
#include "Minisat.h"
#include "CNF_DNF.h"
#include "DSNFFormula.h"
#include "SNFFormula.h"
#include "Translator.h"
#include "DSNFSolver.h"

// Check GCC
#if __GNUC__
#if __x86_64__ || __ppc64__
#define ENVIRONMENT "64 bit"
#else
#define ENVIRONMENT "32 bit"
#endif
#endif

using namespace STRP;

namespace {
const size_t ERROR_IN_COMMAND_LINE = 1;
const size_t SUCCESS = 0;
const size_t ERROR_UNHANDLED_EXCEPTION = 2;

}

const std::string REVISION = "30";
DSNFSolver* solver;

int main(int argc, char **argv) {

	std::string fname_string;

	std::string output[] = { "Unsatisfiable", "Satisfiable" };

	int form_flag = 0;
	int solver_flag = 0;
	int mus_val = 1;
	int sat_flag = 0;
	int help_flag = 1;
	int keep_files = 0;
	int gen_stats = 0;
	int deg_flag = 0;
	int c;
	ANTLR_UINT8* fName;

	while ((c = getopt(argc, argv, "abcdgiktsf:")) != -1)
		switch (c) {
		case 'i':
			form_flag = 1;
			help_flag = 0;
			break;
		case 'k':
			keep_files = 1;
			break;
		case 'a':
			mus_val = 0;
			break;
		case 'b':
			mus_val = 1;
			break;
		case 'c':
			mus_val = 2;
			break;
		case 'd':
			deg_flag = 2;
			break;
		case 'g':
			gen_stats = 1;
			break;
		case 't':
			solver_flag = 1;
			help_flag = 0;
			break;
		case 's':
			sat_flag = 1;
			help_flag = 0;
			break;
		case 'f':
			fName = (ANTLR_UINT8*) optarg;
			fname_string = optarg;
			help_flag = 0;
			break;
		}

	if (help_flag) {
		std::cout << "\n Simplified Temporal Resolution Prover V2.0 "
				<< ENVIRONMENT << " rev." << REVISION << std::endl;
		std::cout << "\n\n Usage STRP_V2 -[OPTIONS]f filename" << std::endl;
		std::cout << "\n -a\tMUS generated by camus_mus";
		std::cout << "\n -b\tMUS generated by mtminer (default)";
		std::cout << "\n -c\tMUS generated by shd";
		std::cout
				<< "\n -d\tGenerate performance stats (time, new universal clauses)";
		std::cout << "\n -g\tGenerate a stats file (cnf_size, mus_size)";
		std::cout << "\n -i\tPrint the DSNF input formula";
		std::cout << "\n -k\tKeep cnf problem and mcs,mus files";
		std::cout << "\n -t\tPrint temporal solver info messages";
		std::cout << "\n -s\tPrint SAT solver info messages\n";
		return SUCCESS;
	}
	try {
		SNFLexer::InputStreamType input(fName, ANTLR_ENC_8BIT);
		SNFLexer lxr(&input);
		SNFParser::TokenStreamType tstream(ANTLR_SIZE_HINT,
				lxr.get_tokSource());
		SNFParser psr(&tstream);

		SNFFormula so = psr.formula();
		//std::cout << so.toString() << std::endl;
		//std::cout << "SNF step clauses: " << so.step.size() << std::endl;
		//std::cout << "Parsed to SNF translating" << std::endl;
		DSNFFormula dsnf = translateToDSNF(so);
		//std::cout << so.table.toString();
		if (form_flag) {
			std::cout << dsnf.toString() << std::endl;
		}
		//std::cout << "DSNF step clauses: " << dsnf.step.size() << std::endl;
		solver = new DSNFSolver(&dsnf, solver_flag, sat_flag, mus_val,
				fname_string, keep_files, gen_stats, deg_flag);
		cout << output[solver->solve()] << endl;
		if (form_flag) {
			std::cout << "step rule applied: " << solver->step_count
					<< std::endl;
			std::cout << "sometime rule applied: " << solver->som_count
					<< std::endl;
			std::cout << "universal clauses generated: " << solver->uni_count
					<< std::endl;

		}

		solver->close_files();

	} catch (std::exception& e) {
		std::cerr << "Exception reached the top of main: " << e.what()
				<< ", application will now exit" << std::endl;
		return ERROR_UNHANDLED_EXCEPTION;
	}

	return SUCCESS;
}
